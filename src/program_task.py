# Author: Andrea Michlíková - xmichl11

import os
import subprocess
import src.shared as shared
from src.log import (
    has_command_run,
    log_command,
    program_to_csv,
    is_program_record_in_csv,
    program_from_log_to_csv,
)
from src.files import count_lines_in_file, create_rules_file_name
from src.files import get_wordlist_info

def handle_pack_special_case(program, rule_file):
    """Handles a special case for the PACK program."""

    if program.name == "PACK":
        # Remove unnecessary files generated by PACK
        file = os.path.splitext(rule_file)[0]
        for ext in [".word", "-sorted.word", ".rule"]:
            if os.path.exists(f"{file}{ext}"):
                os.remove(f"{file}{ext}")

        # Rename the sorted rule file to the expected rule file name
        old_file = f"{file}-sorted.rule"
        rule_file = f"{rule_file}.rule"
        if os.path.exists(old_file):
            os.rename(old_file, rule_file)
    return rule_file


def parse_result(result):
    """Parses the result of a subprocess command."""
    split_stdout = result.stdout.decode('utf-8', errors='ignore').strip().split(',')
    if len(split_stdout) >= 3:
        return split_stdout[0].strip(), split_stdout[1].strip(), split_stdout[2].strip()
    return "N/A", "N/A", "N/A"


def process_run(arg, program, wl, i):
    """Executes a single run of a program with the given arguments."""
    # Create the rule file name
    rule_file = create_rules_file_name(program, wl['name'], i)
    os.makedirs(os.path.dirname(rule_file), exist_ok=True)

    # Handle special naming conventions for the PACK program
    if program.name == "PACK":
        rule_file = os.path.splitext(rule_file)[0]

    # Replace placeholders in the command template with actual values
    cmd = (arg.replace("<run>", program.run).replace("<wordlist>", wl['name']).replace("<rules>", rule_file))

    # Skip execution if the command has already been run
    if shared.LOG and has_command_run(cmd):
        print(f"ALREADY RUN {cmd}")
        if program.name == "PACK":
            rule_file = f"{rule_file}.rule"

        # Log the program to CSV if not already recorded
        if not is_program_record_in_csv(rule_file, wl['name']):
            program_from_log_to_csv(cmd, program.name, i)
        return False

    print(f"RUN: {cmd}")
    result = subprocess.run(f'python3 run_program.py -c "{cmd}"', shell=True, capture_output=True, cwd=shared.SCRIPT_DIR)

    # Handle errors during execution
    if result.returncode != 0:
        print(f"{result.stderr.decode()}")
        if shared.LOG:
            log_command(cmd, "error", error_message=result.stderr.decode())
        if os.path.exists(rule_file):
            os.remove(rule_file)
        return False

    # Handle special cases for PACK and parse the result
    rule_file = handle_pack_special_case(program, rule_file)
    time, memory, cpu = parse_result(result)
    rule_size = count_lines_in_file(rule_file)

    # Log the command and results, save the results to a CSV file
    program_to_csv(program.name, i, rule_file, wl['name'], wl['size'], time, memory, cpu, rule_size)

    if shared.LOG:
        log_command(cmd, "done", rule_file=rule_file, wl=wl['name'], wl_size=str(wl['size']), time=time, memory=memory, cpu=cpu, rule_size=str(rule_size))

    return True 


def run_cmd():
    """Main function to execute commands."""
    for wordlist in shared.WORDLIST_LIST:
        wl_info = get_wordlist_info(wordlist)
        if not wl_info:
            print(f"WARNING: No valid wordlist data found for '{wordlist}'. Skipping.")
            continue
        for program in shared.CONFIG.programs:
            for i, arg in enumerate(program.args):
                for wl in wl_info:
                    process_run(arg, program, wl, i)
